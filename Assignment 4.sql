use mavenmovies;
-- 1- First Normal Form (1NF)
-- Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.
-- actor_award table under award column, film table under special_features violates the rule of 1NF under award column.
-- According to 1NF rule each cell can have only one value but in actor_award table there are multiple values in single cell.
-- To normalize actor_award table we can either pass one value in each cell and create more rows to pass values in them or we can create
-- a new table for actor_award.

-- 2- Second Normal Form (2NF)
-- Choose a table in Sakila and describe how you would determine whether it is in 2NF. If it violates 2NF, explain the steps to normalize it.
-- Film table violates 1NF and 2NF
-- Film table violates 1NF as it has multiple values in single cell under special_features column, it also violates 2NF as it has repetitive
-- columns as title and description which are already available in film_text table.
-- To normalize it we can remove title and description from film table and add film_id as foreign key which will be primary key of film_text table.

-- 3- Third Normal Form (3NF)
-- Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.
-- actor_award table violates 3NF as first_name,last_name is dependent on actor_id which is not primary key in actor_award table.
-- To normalize 3NF we need to eliminate first_name,last_name columns from actor_award table.

-- 4- Normalization Process
-- Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.
-- Film table violates 1NF as it has multiple values in single cell under special_features column
-- To Normalize 1NF we need to pass separate value in each cell under special_features column through insert and update command.
-- Film table also violates 2NF as it has repetitive columns as title and description which are already available in film_text table.
-- To normalize it we can remove title and description from film table and add film_id as foreign key which will be primary key of film_text table.

-- 5- CTE Basics
-- Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor 
-- and film_actor tables.
With actors as
(Select distinct first_name, last_name,actor_id from actor),
film_actors as
(Select concat(first_name," ",last_name) as full_name, film_id from actors inner join film_actor on film_actor.actor_id=actors.actor_id)
Select count(film_id) as Num_of_films , full_name  from film_actors group by full_name;

-- 6- RecuVsive CTE
-- Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the category table in Sakila.
With recursive CategoryHierarchy as (Select category_id, name, parent_id from category where parent_id is null union all
Select c.category_id, c.name, c.parent_id from category c join CategoryHierarchy ch on c.parent_id = ch.category_id)
SELECT * from CategoryHierarchy;

-- 7- CTE with Joins
-- Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.
With film_table as
(Select title,rental_rate,language_id from film),
language_table as 
(Select title,rental_rate,name from film_table inner join language on language.language_id=film_table.language_id)
Select * from language_table;

-- 8- CTE for Aggregation
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payment tables.
With Customer_table as
(Select first_name,last_name,customer_id,email from customer),
payment_table as
(Select first_name,last_name,customer_table.customer_id,email,sum(amount) as total_revenue from customer_table inner join 
payment on payment.customer_id=customer_table.customer_id group by customer_table.customer_id)
Select * from payment_table;

-- 9- CTE with Window Functions
-- Utilize a CTE with a window function to rank films based on their rental duration from the film table.
With film_table as
(Select film_id,title,rental_duration, rank() over (order by rental_duration) as film_rank_based_on_rental_duration from film)
Select * from film_table;

-- 10- CTE and Filtering
-- Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer table
-- to retrieve additional customer details.
With rental_table as
(Select customer_id, count(rental_id) as rental_count from rental group by customer_id having rental_count>2)
Select * from rental_table right join customer on customer.customer_id=rental_table.customer_id;

-- 11- CTE for Date Calculations
-- Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental table.
Select * from rental;
With rental_table as
(Select count(rental_id) as Num_of_rental, monthname(rental_date) as month_name from rental group by monthname(rental_date))
Select * from rental_table;

-- 12- CTE for Pivot Operations
-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in separate columns
-- for different payment methods.
-- No different payment methods available in database
With payment_table as
(Select customer_id,sum(amount) as total_payment from payment group by customer_id)
Select first_name,last_name,payment_table.customer_id,total_payment from payment_table inner join 
customer on customer.customer_id=payment_table.customer_id;

-- 13- CTE and Self-Join
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.
With actor_1 as
(Select actor_id,film_id from film_actor),
actor_2 as
(Select actor_id,film_id from film_actor)
Select actor_1.film_id,actor_1.actor_id,actor_2.actor_id from actor_1 inner join actor_2 on actor_1.film_id=actor_2.film_id
where actor_1.film_id=actor_2.film_id;

-- 14- CTE for Recursive Search
-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reports_to column.
With Recursive staff_manager as (Select staff_id, reports_to from staff union all Select s.staff_id, s.reports_to from staff as s inner join
 staff_manager sm ON s.reports_to = sm.staff_id)
SELECT * from staff_manager;
-- Note: The staff table on the provided databse doesn't contain reports to column.
